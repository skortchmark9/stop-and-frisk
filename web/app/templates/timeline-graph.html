<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="../static/css/timeline-graph.css">
	<script src="../static/js/timeline-graph.js"></script>
	<script src="http://d3js.org/d3.v3.js"></script>
	<script src="http://d3js.org/queue.v1.min.js"></script>

	<style>

body {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

</style>
	
</head>

<body onload="timeline_graph_init()">

	<script>

	var margin = {top: 20, right: 80, bottom: 30, left: 50},
	width = 960 - margin.left - margin.right,
	height = 200 - margin.top - margin.bottom;

	var parseDate = d3.time.format("%d%m%Y").parse;

	var x = d3.time.scale()
	.range([0, width]);

	var y = d3.scale.linear()
	.range([height, 0]);

	var color = d3.scale.category10();

	var xAxis = d3.svg.axis()
	.scale(x)
	.orient("bottom");

	var yAxis = d3.svg.axis()
	.scale(y)
	.orient("left");

	var line = d3.svg.line()
	.interpolate("basis")
	.x(function(d) { return x(d.date); })
	.y(function(d) { return y(d.chance); });

	var svg = d3.select("body").append("svg")
	.attr("width", width + margin.left + margin.right)
	.attr("height", height + margin.top + margin.bottom)
	.append("g")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	//http://bl.ocks.org/mbostock/3884955

	queue()
	.defer(d3.json, "../static/data/test-graph-data.json")
	.defer(d3.json, "../static/data/test-graph-data-2.json")
	.await(analyze);

	function analyze(error, data, data2){
		color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

		/*data.forEach(function(d) {
			d.date = parseDate(d.date);
		});

		data2.forEach(function(d) {
			d.date = parseDate(d.date);
		});*/

		var cities = color.domain().map(function(name) {
			return {
				name: name,
				values: data.map(function(d) {
					//return {date: d.date, chance: +d[name]};
					return {date: d.date, chance: 
						d3.mean(color.domain().map(function(e) {return +d[e]; } ))};
					})
			};
		});


		var nest = d3.nest()
		.key(function (d) {
			return d.date;
		})
		.entries(data);

		var nest2 = d3.nest()
		.key(function (d) {
			return d.date;
		})
		.entries(data2);

		//console.log(nest)

		var test = [{name: "total",
		values: nest.map(function(d){
			return {
				date: parseDate(d.key),
				chance: d3.mean(d.values.map(function(e){
					return e["chance"];
				}))
			}
		})}, 
			{name: "current",
		values: nest2.map(function(d){

			return {
				date: parseDate(d.key),
				chance: d3.mean(d.values.map(function(e){
					return e["chance"];
				}))
			}
		})}]

		data.forEach(function(d) {
			d.date = parseDate(d.date);
		});

		data2.forEach(function(d) {
			d.date = parseDate(d.date);
		});

		x.domain(d3.extent(data.concat(data2), function(d) { return d.date; }));

		y.domain([
			d3.min(test, function(c) { return d3.min(c.values, function(v) { return v.chance; }); }),
			d3.max(test, function(c) { return d3.max(c.values, function(v) { return v.chance; }); })
			]);

		svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

		svg.append("g")
		.attr("class", "y axis")
		.call(yAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("Chance of Stop/Frisk");

		var city = svg.selectAll(".city")
		.data(test)
		.enter().append("g")
		.attr("class", "city");

		city.append("path")
		.attr("class", "line")
		.attr("d", function(d) { 
			//console.log(d.values)
			return line(d.values); })
		.style("stroke", function(d) { return color(d.name); });

		city.append("text")
		.datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
		.attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.chance) + ")"; })
		.attr("x", 3)
		.attr("dy", ".35em")
		.text(function(d) { return d.name; });

	}

	/*d3.json("../static/data/test-graph-data.json", function(error, data) {

		color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

		var cities = color.domain().map(function(name) {
			return {
				name: name,
				values: data.map(function(d) {
					//return {date: d.date, chance: +d[name]};
					return {date: d.date, chance: 
						d3.mean(color.domain().map(function(e) {return +d[e]; } ))};
					})
			};
		});

		var nest = d3.nest()
		.key(function (d) {
			return d.date;
		})
		.entries(data);

		var test = [{name: "total",
		values: nest.map(function(d){
			return {
				date: d.key,
				chance: d3.mean(d.values.map(function(e){
					return e["chance"];
				}))
			}
		})}]

		console.log(test)
		console.log(cities)

		x.domain(d3.extent(data, function(d) { return d.date; }));

		y.domain([
			d3.min(test, function(c) { return d3.min(c.values, function(v) { return v.chance; }); }),
			d3.max(test, function(c) { return d3.max(c.values, function(v) { return v.chance; }); })
			]);

		svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

		svg.append("g")
		.attr("class", "y axis")
		.call(yAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("Chance of Stop/Frisk");

		var city = svg.selectAll(".city")
		.data(test)
		.enter().append("g")
		.attr("class", "city");

		city.append("path")
		.attr("class", "line")
		.attr("d", function(d) { 
			return line(d.values); })
		.style("stroke", function(d) { return color(d.name); });

		city.append("text")
		.datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
		.attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.chance) + ")"; })
		.attr("x", 3)
		.attr("dy", ".35em")
		.text(function(d) { return d.name; });
	});*/

	/*d3.tsv("data.tsv", function(error, data) {
		color.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

		data.forEach(function(d) {
			d.date = parseDate(d.date);
		});

		var cities = color.domain().map(function(name) {
			return {
				name: name,
				values: data.map(function(d) {
					return {date: d.date, temperature: +d[name]};
				})
			};
		});

		x.domain(d3.extent(data, function(d) { return d.date; }));

		y.domain([
			d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.temperature; }); }),
			d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.temperature; }); })
			]);

		svg.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + height + ")")
		.call(xAxis);

		svg.append("g")
		.attr("class", "y axis")
		.call(yAxis)
		.append("text")
		.attr("transform", "rotate(-90)")
		.attr("y", 6)
		.attr("dy", ".71em")
		.style("text-anchor", "end")
		.text("Temperature (ÂºF)");

		var city = svg.selectAll(".city")
		.data(cities)
		.enter().append("g")
		.attr("class", "city");

		city.append("path")
		.attr("class", "line")
		.attr("d", function(d) { return line(d.values); })
		.style("stroke", function(d) { return color(d.name); });

		city.append("text")
		.datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
		.attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
		.attr("x", 3)
		.attr("dy", ".35em")
		.text(function(d) { return d.name; });
	});*/

</script>

</div>
</body>
</html>
